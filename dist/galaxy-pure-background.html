<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pure Galaxy Background</title>
    
    <!-- Three.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
    
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #0A0A0F;
        }
        
        canvas {
            display: block;
            width: 100%;
            height: 100vh;
        }
        
        /* Accessibility */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
    </style>
</head>
<body>
    <!-- Pure Galaxy Canvas -->
    <canvas id="galaxyCanvas"></canvas>
    
    <script>
        // Global variables
        let scene, camera, renderer, starField, nebulaPlane;
        let animationPaused = false;
        let currentThemeIndex = 0;
        let themeTimer = 0;
        let lastTime = 0;
        let deltaTime = 0;
        let mouse = { x: 0, y: 0 };
        
        // Theme definitions (5 crypto themes)
        const THEMES = [
            { name: 'BTC', colors: ['#2b1900', '#8a4b00'], accent: '#F7931A' },
            { name: 'ETH', colors: ['#0b0820', '#4a3fb8'], accent: '#8A7AFF' },
            { name: 'SOL', colors: ['#001b1b', '#116b68'], accent: '#00E6A8' },
            { name: 'XRP', colors: ['#001526', '#0c3a66'], accent: '#4EA1FF' },
            { name: 'ADA', colors: ['#001b1f', '#0e5660'], accent: '#3AC7D0' }
        ];
        
        // Nebula shader
        const nebulaVertexShader = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;
        
        const nebulaFragmentShader = `
            uniform float u_time;
            uniform vec3 u_color1;
            uniform vec3 u_color2;
            varying vec2 vUv;
            
            float noise(vec2 p) {
                return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
            }
            
            float smoothNoise(vec2 p) {
                vec2 i = floor(p);
                vec2 f = fract(p);
                f = f * f * (3.0 - 2.0 * f);
                
                float a = noise(i);
                float b = noise(i + vec2(1.0, 0.0));
                float c = noise(i + vec2(0.0, 1.0));
                float d = noise(i + vec2(1.0, 1.0));
                
                return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
            }
            
            float fbm(vec2 p) {
                float value = 0.0;
                float amplitude = 0.5;
                for(int i = 0; i < 6; i++) {
                    value += amplitude * smoothNoise(p);
                    p *= 2.0;
                    amplitude *= 0.5;
                }
                return value;
            }
            
            void main() {
                vec2 uv = vUv;
                vec2 center = vec2(0.5, 0.5);
                float dist = distance(uv, center);
                
                // Animated noise
                vec2 noiseUv = uv * 3.0 + u_time * 0.1;
                float noiseValue = fbm(noiseUv);
                
                // Radial gradient
                float radial = 1.0 - smoothstep(0.0, 0.8, dist);
                
                // Combine noise and radial
                float alpha = radial * (0.3 + 0.4 * noiseValue);
                
                // Color mixing
                vec3 color = mix(u_color1, u_color2, noiseValue);
                
                gl_FragColor = vec4(color, alpha * 0.6);
            }
        `;
        
        // Initialize Three.js Galaxy
        const initGalaxy = () => {
            const canvas = document.getElementById('galaxyCanvas');
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            
            // Create starfield
            createStarField();
            
            // Create nebula
            createNebula();
            
            camera.position.z = 5;
            
            // Mouse parallax
            document.addEventListener('mousemove', (event) => {
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            });
        };
        
        const createStarField = () => {
            const starCount = window.innerWidth < 640 ? 800 : 2000;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(starCount * 3);
            const colors = new Float32Array(starCount * 3);
            const sizes = new Float32Array(starCount);
            
            for (let i = 0; i < starCount; i++) {
                // Distribute in sphere
                const radius = 20 + Math.random() * 30;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                
                positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                positions[i * 3 + 2] = radius * Math.cos(phi);
                
                // Random colors (white to blue-white)
                const color = new THREE.Color();
                color.setHSL(0.6 + Math.random() * 0.1, 0.2 + Math.random() * 0.3, 0.7 + Math.random() * 0.3);
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
                
                // Random sizes
                sizes[i] = 0.5 + Math.random() * 1.5;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            const material = new THREE.PointsMaterial({
                size: 1,
                sizeAttenuation: true,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                transparent: true,
                opacity: 0.8
            });
            
            starField = new THREE.Points(geometry, material);
            scene.add(starField);
        };
        
        const createNebula = () => {
            const geometry = new THREE.PlaneGeometry(50, 50);
            const material = new THREE.ShaderMaterial({
                vertexShader: nebulaVertexShader,
                fragmentShader: nebulaFragmentShader,
                uniforms: {
                    u_time: { value: 0 },
                    u_color1: { value: new THREE.Color(THEMES[0].colors[0]) },
                    u_color2: { value: new THREE.Color(THEMES[0].colors[1]) }
                },
                transparent: true,
                blending: THREE.AdditiveBlending
            });
            
            nebulaPlane = new THREE.Mesh(geometry, material);
            nebulaPlane.position.z = -10;
            scene.add(nebulaPlane);
        };
        
        // Theme management
        const updateTheme = (themeIndex) => {
            const theme = THEMES[themeIndex];
            currentThemeIndex = themeIndex;
            
            // Update nebula colors
            if (nebulaPlane) {
                const material = nebulaPlane.material;
                const startColor1 = material.uniforms.u_color1.value.clone();
                const startColor2 = material.uniforms.u_color2.value.clone();
                const targetColor1 = new THREE.Color(theme.colors[0]);
                const targetColor2 = new THREE.Color(theme.colors[1]);
                
                let progress = 0;
                const transition = () => {
                    progress += 0.02;
                    if (progress <= 1) {
                        material.uniforms.u_color1.value.lerpColors(startColor1, targetColor1, progress);
                        material.uniforms.u_color2.value.lerpColors(startColor2, targetColor2, progress);
                        requestAnimationFrame(transition);
                    }
                };
                transition();
            }
        };
        
        // Animation loop
        const animate = (currentTime) => {
            if (animationPaused) return;
            
            requestAnimationFrame(animate);
            
            deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            
            // Limit to 30fps on low-end devices
            if (deltaTime < 33) return;
            
            // Update time uniform
            if (nebulaPlane) {
                nebulaPlane.material.uniforms.u_time.value = currentTime * 0.001;
            }
            
            // Rotate starfield
            if (starField) {
                starField.rotation.y += 0.0002;
                starField.rotation.x += 0.0001;
                
                // Parallax effect
                const parallaxStrength = window.innerWidth < 640 ? 0.02 : 0.05;
                starField.rotation.z = mouse.x * parallaxStrength;
                starField.position.x = mouse.x * parallaxStrength * 2;
                starField.position.y = mouse.y * parallaxStrength;
            }
            
            // Auto theme cycling every 6 seconds
            themeTimer += deltaTime;
            if (themeTimer >= 6000) {
                themeTimer = 0;
                const nextTheme = (currentThemeIndex + 1) % THEMES.length;
                updateTheme(nextTheme);
            }
            
            renderer.render(scene, camera);
        };
        
        // Event handlers
        const setupEventHandlers = () => {
            // Visibility API
            document.addEventListener('visibilitychange', () => {
                animationPaused = document.hidden;
                if (!animationPaused) {
                    lastTime = performance.now();
                    animate(lastTime);
                }
            });
            
            // Resize handler
            window.addEventListener('resize', () => {
                if (camera && renderer) {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                }
            });
            
            // Respect reduced motion
            if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                animationPaused = true;
            }
        };
        
        // Initialize everything
        const init = () => {
            initGalaxy();
            setupEventHandlers();
            updateTheme(0);
            
            // Start animation
            lastTime = performance.now();
            animate(lastTime);
        };
        
        // Start when DOM is ready
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>